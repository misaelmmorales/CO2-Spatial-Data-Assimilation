!C
!C  FILE:random.for
!C  DRIVER FOR RANDOM NUMBER GENERATOR
!C
!C  WRITTEN BY ALBERT C. REYNOLDS, JR. JULY, 1993
!C
!C  THIS PROGRAM CALLS FUNCTIONS RAN2 AND GASDEV
!C  FROM NUMERICAL RECIPES,
!C  PRESS ET AL., CAMBRIDGE UNIVERSITY PRESS
!C
!C  THIS PROGRAM ALLOWS THE USER TO GENERATE N INDEPENDENT
!C  SAMPLE OF A RANDOM VARIABLE, X,  WITH THE SEQUENCE OF
!C  NUMBERS (SAMPLES, REALIZATIONS) STORED IN THE ARRAY RNSEQ1
!C  THIS ARRAY AND RSLOGN ARE CURRENTLY DIMENSIONED TO 10000
!C  IF X IS LOG-NORMAL, THE VALUES OF X ARE STORED IN RNSEQ1
!C  THE VALUES OF LN(X) ARE STORED IN RNLOGN. IN ALL OTHER CASES
!C  RNLOGN AND RNSEQ1 STORE THE REALIZATIONS OF X. 
!C
!C  RNSEQ1  IS OUTPUT INTO FILE RESULT.DAT. IF WE GENERATE
!C  STANDARD RANDOM NORMAL DEVIATES IN RNSEQ1,
!C   THIS FILE CAN BE READ INTO ANOTHER PROGRAM
!C  AND MULTIPLIED BY THE SQUARE ROOT OF A COVARIANCE MATRIX
!C  AND ADDED TO THE MEAN VECTOR TO GET AN UNCONDITIONAL REALIZATION
!C  OF A CORRELATED RANDOM FIELD. 
!C  
!C  
!C  I1 AND I2 MUST BE INTEGERS INPUT
!C  THE PROGRAM WILL THEN GENERATE RANDOM NUMBERS BETWEEN
!C  I1 AND I2 IF WE ARE USING A UNIFORM DISTRIBUTION - ITYPE = 1
!C  ON DATA CARD 3.  IF WE SEEK NORMAL DEVIATIES (ITYPE =2)
!C  OR LOGNORMAL DEVIATES (ITYPE=3),
!C  THEN I1 AND I2 ARE READ BUT IGNORED
!CC
!C  N1 SHOULD BE THOUGHT OF AS THE NUMBER OF GRIDBLOCKS IN
!C  THE FIRST DIRECTION (r or x) AND N2 SHOULD BE THOUGHT OF AS THE
!C   NUMBER OF GRIDBLOCKS IN THE SECOND DIRECTION (theta or y)
!C   N= N1 * N2 GIVES THE TOTAL NUMBER OF GRIDBLOCKS WHICH IS
!C   EQUAL TO THE TOTAL NUMBER OF RANDOM VARIABLES GENERATED BY
!C   THIS PROGRAM.  THESE N RANDOM NUMBERS
!C   ARE STORED IN THE ARRAY RNSEQ1
!C  N= N1*N2  MUST BE LESS THAN OR EQUAL TO 2500
!C  OR THE THE DIMENSION IN THE RNSEQ1 ARRAY MUST BE INCREASED
!C
!C  THE FOUR PARAMETERS ARE READ IN ON FIRST LINE OF DATA FILE RAN.DAT
!C  AS INTEGERS IN THE FOLLOWING ORDER
!C
!C  DATA FILE LINE 1
!C  I1   I2  N1 N2 IOUTRN
!C  WHERE IOUTRN GIVES FORMAT FOR OUTPUT FILE
!C  IF IOUTRN = 1, RANDOM NUMBERS OUTPUT WITH F18.6 FORMAT
!C  IF IOUTRN =2,  RANDOM NUMBERS ARE OUTPUT WITH 1PE15.6 FORMAT
!C
!C  DATA LINE 2 IS
!C  IDUM1
!C  IDUM1 IS THE SEED FOR GENERATING A SEQUENCE OF RANDOM NUMBERS
!C  WRITTEN TO ARRAY RNSEQ1;  IDUM1 MUST BE A NEGATIVE INTEGER
!C  NO LONGER THAN SIX DIGITS
!C
!C  DATA LINE 3
!C  ITYPE
!C  WHERE ITYPE =1 GIVES A SEQUENCE OF UNIFORM DEVIATES
!C  AND   ITYPE = 2 GIVES A SEQUENCE OF NORMALLY DISTRIBUTED
!C  DEVIATES WITH MEAN XM AND STANDARD DEVIATION EQUAL TO XSD.
!C  ITYPE = 3 GIVES SAMPLES OF RANDOM VARIABLE  ASSUMING THAT
!C  X HAS A LOG-NORMAL DISTRIBUTION, I.E., LN(X)
!C  HAS A NORMAL DISTRIBUTION WITH MEAN OF LN(X) GIVEN BY
!C  XM (SEE DATA LINE 4) AND STANDARD DEVIATION OF LN(X) GIVEN
!C  BY XSD
!C
!C
!C  DATA LINE 4 IS READ IF AND ONLY IF ITYPE = 2 OR ITYPE =3
!C  IF ITYPE IS NOT EQUAL TO 2 OR 3 DO NOT INCLUDE THIS DATA
!C  XM, XSD, INORM
!C  IF ITYPE=2, XM=MEAN OF VARIABLE X, XSD ITS STANDARD DEVIATION
!C  REGARDLESS OF THE VALUE OF INORM
!C  IF ITYPE=3 AND INORM=1, THEN
!C  XM IS THE MEAN AND XSD THE STANDARD DEVIATION OR X, BUT
!C  IF ITYPE = 3 AND INORM =2, THEN
!C  XM IS THE MEAN FOR NATURAL LOG OF X AND
!C  XSD IS THE STANDARD DEVIATION FOR NATURAL LOG OF X
!C
!C
!	DIMENSION RNSEQ1(10000)
!	DIMENSION RNLOGN(10000)
!	CHARACTER CH(80)*1
!	INTEGER I1, I2, N1, N2
!	INTEGER IDUM1, INORM, IOUTRN
!C
!C     REMOVE COMMENTS FROM DATA FILE
!C     TO CREATE WORKING DATA FILE
!C
!	OPEN (104, FILE='ranin.dat', STATUS='OLD')
!	OPEN (105, FILE='ran.dat', STATUS='UNKNOWN')
!	DO 3 I = 1, 50
!	READ(104, 100) CH
!	IF(CH(1).NE.'C'.AND.CH(1).NE.'c') THEN
!	WRITE(105,100) CH
!	ENDIF
!    3 CONTINUE
!  100 FORMAT(80A1)
!	REWIND(105)
!	OPEN (108, FILE='result.ran', STATUS='UNKNOWN')
!	OPEN (110, FILE='randomdev.dat', STATUS='UNKNOWN')
!	READ(105,*) I1, I2, N1, N2, IOUTRN
!CC    READ THE SEED VALUE
!	READ(105,*) IDUM1
!	READ(105,*) ITYPE
!	N=N1*N2
!	DO 5 I=1,N
!	RNSEQ1(I) = 0.0
!	RNLOGN(I) = 0.0
!    5 CONTINUE
!	WRITE(108,900)
!  900 FORMAT('C',2X,'FILE RESULT.RAN, OUTPUT FILE FOR RANDOM.FOR')
!	IF (ITYPE.EQ.1) THEN
!	WRITE(108,1000) N, I1, I2
!	ENDIF
!	IF (ITYPE.EQ.2)  THEN
!	WRITE(108,1100) N
!	ENDIF
!	IF (ITYPE.EQ.3) THEN
!	WRITE(108,1200)  N
!	ENDIF
!	WRITE(108,1250) IDUM1
! 1000 FORMAT('C', 5X,I7,3X, 'RANDOM NOS BETWEEN', I5, I5)
! 1100 FORMAT('C',2X, I7, 3X, 'NORMALLY DISTRIBUTED RANDOM NUMBERS')
! 1200 FORMAT('C',2X,I7,2X, 'LOG-NORMALLY DISTRIBUTED RANDOM NOS')
! 1250 FORMAT('C',2X,'GENERATED WITH SEED = ',2X, I18)
!	 IF(ITYPE.NE.1) THEN
!	 READ(105,*) XM, XSD, INORM
!	   IF(INORM.EQ.1) WRITE(108,1280)
!	   IF(INORM.EQ.2) WRITE(108,1290)
!	   IF (INORM.EQ.1) THEN
!	   WRITE(108,1300) XM, XSD
!	   ENDIF
!	 ENDIF
! 1280 FORMAT('C',2X, 'HAVE INPUT MEAN AND STAND. DEV. OF VAR.')
! 1290 FORMAT('C',2X,'HAVE INPUT MEAN AND STAND. DEV. OF LN(VAR)')
! 1300 FORMAT('C',2X,'MEAN =', F12.6,2X, 'STANDARD DEVIATION = ', F12.6)
! 1400 FORMAT('C',2X, 'FOLLOWING REFER TO LN OF THE VARIABLE')
! 1500 FORMAT('C',2X,'MEAN=', E12.5,2X,'STANDARD DEVIATION = ',E12.5)
!	  IF(ITYPE.EQ.3.AND.INORM.EQ.2) THEN
!	  WRITE(108,1400)
!	  WRITE(108,1500) XM, XSD
!C
!C       XM AND XSD REFER TO LN(X)  -  WE WANT TO COMPUTE MEAN
!C       AND STANDARD DEVIATION OF X
!C
!	  YTEMP = XSD*XSD
!	  XMLN = EXP(XM + 0.5 * YTEMP)
!	  XTEMP = EXP(2.0 * XM + YTEMP)*( EXP(YTEMP) - 1.0)
!	  XSDLN = SQRT(XTEMP)
!	  WRITE(108,1540)
!	  WRITE(108,1550) XMLN, XSDLN
! 1540   FORMAT('C',2X,'FOLLOWING REFER TO THE VARIABLE, NOT LN(VAR)')
! 1550   FORMAT('C',2X, 'MEAN= ',1X, F15.6, 2X,
!     1  'STANDARD DEVIATION =',2X, F15.6)
!	  ENDIF
!C  IF INORM =1, THEN XM AND XSD WILL ALWAYS BE READ AS
!C  THE MEAN AND STANDARD DEVIATION OF
!C  THE VARIABLE, DENOTED HERE BY X.
!C
!C  THE REMAINDER OF THIS COMMENT PERTAINS TO THE CASE WHERE
!C  X IS LOG-NORMALLY DISTRIBUTED SO ITYPE=3 ON INPUT
!C  IF INORM=1, WE MUST CALCULATE THE MEAN AND STANDARD DEVIATION OF
!C  LN(X) AS DONE IN THE FOLLOWING CODE.
!C  HOWEVER, IF INORM=2, WE READ IN DIRECTLY
!C  XM AND XSD AS THE MEAN AND STANDARD DEVIATION OF  LN(X) AND WE SKIP
!C  THE CONVERSION TO THE MEAN AND SDV OF LN(X).
!C
!	 IF(ITYPE.EQ.3.AND.INORM.NE.2) THEN
!	 X1TT =  (XSD*XSD)/(XM*XM)  + 1.00000
!	 X1TT = LOG(X1TT)
!	 XM = LOG(XM) - (X1TT/2.0)
!	 XSD = SQRT(X1TT)
!	 WRITE(108,1400)
!	 WRITE(108,1500)  XM, XSD
!	 ENDIF
!	DO 7 I=1,N
!	 IF (ITYPE.EQ.1) THEN
!	 II1I2 = I2 - I1
!	 RNSEQ1(I) = I1 +  II1I2*RAN2(IDUM1)
!	 RNLOGN(I)=RNSEQ1(I)
!	 ENDIF
!	   IF (ITYPE.NE.1) THEN
!	   RNSEQ1(I) = GASDEV(IDUM1)
!CC
!CC       IF ITYPE.NE.1, THEN AT THIS POINT THE NUMBER RNSEQ1(I)
!CC       IS A SAMPLED VALUE OF A RANDOM VARIABLE WHICH HAS A
!CC       NORMAL DISTRIBUTION WITH  MEAN 0 AND STANDARD DEV =1.00
!CC       WE NOW CONVERT TO A RANDOM VARIABLE VALUE XNOM FOR
!CC       A VARIABLE
!CC       WITH MEAN=XM AND STANDARD DEVIATION = XSD
!C        FOR A VARIABLE X HAVING A LOGNORMAL DISTRIBUTION (ITYPE=3), XNORM IS
!C        THE VALUE OF  LN(X) AND WE THEN HAVE TO CONVERT BACK TO X.
!CC
!	  XNORM =  XM  +  XSD * RNSEQ1(I)
!	   IF(ITYPE.EQ.2) RNSEQ1(I) = XNORM
!	      IF(ITYPE.EQ.2) RNLOGN(I) = XNORM
!		IF(ITYPE.EQ.3) THEN
!	    RNLOGN(I)=XNORM
!		XLNNOR = EXP(XNORM)
!		RNSEQ1(I) = XLNNOR
!		ENDIF
!	   ENDIF
!	 IF (IOUTRN.EQ.1) THEN
!	 WRITE (108,3000) RNSEQ1(I), RNLOGN(I)
!	 ELSE
!	 WRITE(108,3100) RNSEQ1(I), RNLOGN(I)
!	 ENDIF
! 3000 FORMAT(1X, F18.6,5X,F18.6)
! 3100 FORMAT(1X, 1PE15.6,5X,1PE15.6)
!      WRITE(110,*) RNSEQ1(I)  
!    7 CONTINUE
!	IF(IDUM1.GT.0) IDUM1 = - IDUM1
!	WRITE (108, 3200) IDUM1
! 3200 FORMAT('C',3X,'POSSIBLE VALUE OF SEED FOR NEW SEQUENCE = ', I16)
!C
!C  COMPUTE MEAN OF SAMPLE, STANDARD DEVIATION OF THE SAMPLE
!C  AND UNBIASED ESTIMATE OF THE
!C  STANDARD DEVIATION OF THE RANDOM VARIABLE ASSOCIATED WITH
!C  THE PARENT DISTRIBUTION FROM WHICH THE SAMPLE IS DRAWN, I.E.,
!C  IF S**2 IS THE STANDARD DEVIATION OF THE RANDOM VARIABLE
!C  AND SIG**2 IS THE STANDARD DEVIATION OF THE SAMPLE
!C  THEN HERE WE ARE COMPUTING AN ESTIMATE OF S**2 BY THE FORMULA
!C  S**2 = ( N/ [N-1]) SIG**2
!C  BELOW
!C  SPMEAN = SAMPLE MEAN
!C  SIG = STANDARD DEVIATION OF THE SAMPLE
!C  S2 DENOTES THE ESTIMATE OF THE STAND. DEV. OF THE RANDOM VARIABLE
!C
!C
!	SUM1=0.0
!	SUM2=0.0
!	DO 8 I=1, N
!	XT  =  RNSEQ1(I)
!	SUM1 = SUM1 + XT
!	SUM2 = SUM2 + XT*XT
!    8 CONTINUE
!	SPMEAN = SUM1/N
!	SIG  = SQRT (   (SUM2/ N)  - (SPMEAN*SPMEAN))
!	S2 = (N * SIG**2) / (N-1)
!	S2=SQRT(S2)
!	WRITE(108,4000) SPMEAN
! 4000 FORMAT('C', 3X, 'MEAN OF THE SAMPLE = ',2X, 1PE14.5)
!	WRITE(108,4100) SIG
! 4100 FORMAT('C',3X,'STANDARD DEVIATION OF THE SAMPLE = ', 2X, 1PE14.5)
!	WRITE(108,4200) S2
! 4200 FORMAT('C', 2X, 'UNBIASED EST. OF STAND. DEV. RANDOM VAR.=',
!     1 1PE14.5)
!C
!C
!C     COMPUTE AND PRINT  LOG MEAN SAMPLE AND STANDARD DEVIATION OF LN(X)
!C     IF VARIABLE IS LOG-NORMALLY DISTRIBUTED
!C
!	 IF(ITYPE.EQ.3) THEN
!	 SUM1=0.0
!	 SUM2=0.0
!	  DO 9 I=1, N
!	  XT  =  LOG ( RNSEQ1(I) )
!	  SUM1 = SUM1 + XT
!	  SUM2 = SUM2 + XT*XT
!    9   CONTINUE
!	 SPMEAN = SUM1/N
!	 SIG  = SQRT (   (SUM2/ N)  - (SPMEAN*SPMEAN))
!	S2 = (N * SIG**2) / (N-1)
!	S2=SQRT(S2)
!	 WRITE(108,4300) SPMEAN
! 4300  FORMAT('C', 3X, 'MEAN OF THE SAMPLE OF LN(X) = ',2X, 1PE14.5)
!	 WRITE(108,4400) SIG
! 4400  FORMAT('C',3X,'STAND. DEV. OF SAMPLE OF LN(X)= ',2X, 1PE14.5)
!	 WRITE(108,4500)
! 4500  FORMAT('C', 2X, 'UNBIASED EST. OF STANDARD DEVIATION OF THE')
!	 WRITE(108,4600) S2
! 4600  FORMAT('C',2X, 'RANDOM VARIABLE LN(X) =',2X, 1PE14.5)
!	 ENDIF
!	CLOSE(UNIT=105)
!      CLOSE(UNIT=108)
!	CLOSE(UNIT=110)
!      END
!C
!C  FUNCTION FOR GENERATING A NORMALLY (GAUSSIAN) DISTRIBUTED DEVIATE
!C  WITH ZERO MEAN AND UNIT STANDARD DEVIATION,  USES FUNCTION RAN2
!C  AS THE SOURCE OF THE UNIFORM DEVIATES
!C
!C
	FUNCTION gasdev(idum)
      INTEGER idum
      REAL gasdev
CU    USES ran2
      INTEGER iset
	REAL fac,gset,rsq,v1,v2,ran2
      SAVE iset,gset
      DATA iset/0/
      if (iset.eq.0) then
1       v1=2.*ran2(idum)-1.
	  v2=2.*ran2(idum)-1.
        rsq=v1**2+v2**2
        if(rsq.ge.1..or.rsq.eq.0.)goto 1
        fac=sqrt(-2.*log(rsq)/rsq)
        gset=v1*fac
        gasdev=v2*fac
        iset=1
      else
        gasdev=gset
        iset=0
      endif
      !open(2,file='.\seed.dat',status='unknown')
      !write(2,*) idum
      !close(2)
      return
      
      END
C  (C) Copr. 1986-92 Numerical Recipes Software
      FUNCTION ran2(idum)
      INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV
      REAL ran2,AM,EPS,RNMX
      PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
     *IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,IR2=3791,
     *NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
      INTEGER idum2,j,k,iv(NTAB),iy
      SAVE iv,iy,idum2
      DATA idum2/123456789/, iv/NTAB*0/, iy/0/
      if (idum.le.0) then
        idum=max(-idum,1)
        idum2=idum
        do 11 j=NTAB+8,1,-1
          k=idum/IQ1
          idum=IA1*(idum-k*IQ1)-k*IR1
          if (idum.lt.0) idum=idum+IM1
          if (j.le.NTAB) iv(j)=idum
11      continue
        iy=iv(1)
      endif
      k=idum/IQ1
      idum=IA1*(idum-k*IQ1)-k*IR1
      if (idum.lt.0) idum=idum+IM1
      k=idum2/IQ2
      idum2=IA2*(idum2-k*IQ2)-k*IR2
      if (idum2.lt.0) idum2=idum2+IM2
      j=1+iy/NDIV
      iy=iv(j)-idum2
      iv(j)=idum
      if(iy.lt.1)iy=iy+IMM1
      ran2=min(AM*iy,RNMX)
      return
      END
C  (C) Copr. 1986-92 Numerical Recipes Software
